```mermaid

erDiagram
    CUSTOMER ||--o{ INVOICE : places
    INVOICE ||--o{ INVOICE_ITEM : contains
    PRODUCT ||--o{ INVOICE_ITEM : appears_in
    CUSTOMER ||--o{ ADDRESS : has

    CUSTOMER {
        int customer_id PK
        string first_name
        string last_name
        string email
    }

    ADDRESS {
        int address_id PK
        int customer_id FK
        string street
        string city
        string country
    }

    INVOICE {
        int invoice_id PK
        int customer_id FK
        date invoice_date
        decimal total_amount
    }

    INVOICE_ITEM {
        int invoice_item_id PK
        int invoice_id FK
        int product_id FK
        int quantity
        decimal unit_price
    }

    PRODUCT {
        int product_id PK
        string product_name
        decimal price
    }
```
## Docker Compose Architecture

```mermaid
flowchart LR
    direction LR
    frontend[Frontend]
    backend_hibernate[backend-hibernate]
    backend_jooq[backend-jooq]
    postgres[(PostgreSQL)]

    %% Frontend can call either backend
    frontend -->|calls / HTTP| backend_hibernate
    frontend -->|calls / HTTP| backend_jooq

    %% Backends contact the database
    backend_hibernate -->|JDBC| postgres
    backend_jooq -->|JDBC| postgres
```

This diagram shows that the `frontend` service calls either `backend-hibernate` or `backend-jooq`, and both backends connect to the `PostgreSQL` database.


## Problem with JOOQ Metamodel

1. I want a easily buildable system with `mvn clean package`
2. To keep the metamodel up-to-date i would like to create the model every time i build.
Explained at (jooq.org)[https://www.jooq.org/doc/latest/manual/code-generation/codegen-version-control/#derived-artefacts].
3. Building the metamodel depends on a running database with all the flyway scripts applied.

This seems like a big problem, if i don't want to keep my metamodel (in the `target` folder), because
i can't startup my application without the metamodel-classes (build error).

```mermaid
flowchart TD
    %% Core artifacts
    SRC[Application Source Code\nUses jOOQ DSL]
    META[jOOQ Metamodel\nGenerated Classes]
    GEN[jOOQ Generator]
    DB[(Database\nSchema State)]
    FLY[Flyway Migration Scripts]

    %% Compile and generation dependencies
    SRC -->|Compile time dependency| META
    META -->|Generated by| GEN
    GEN -->|Introspects| DB

    %% Database lifecycle
    FLY -->|Applied to| DB

    %% Execution requirements
    SRC -->|Must compile to run| FLY

    %% Fresh clone situation
    CLONE[Fresh Repository Clone\nTarget directory empty\nNo jOOQ Metamodel]
    CLONE --> SRC
    CLONE --> FLY

    %% Explanatory notes
    N1["Application cannot compile\nbecause jOOQ metamodel is missing"]
    N2["jOOQ metamodel cannot be generated\nbecause database schema does not exist yet"]
    N3["Database schema does not exist\nbecause Flyway migrations are not applied"]
    N4["Flyway migrations cannot run\nbecause application does not compile"]

    SRC -.-> N1
    GEN -.-> N2
    DB -.-> N3
    FLY -.-> N4

    %% Deadlock highlight
    DEADLOCK["BOOTSTRAP DEADLOCK\nNo entry point to start the build"]
    N1 --> DEADLOCK
    N2 --> DEADLOCK
    N3 --> DEADLOCK
    N4 --> DEADLOCK
```

Right now my solution is to add the metamodel to git. ðŸ˜¥